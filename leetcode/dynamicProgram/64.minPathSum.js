/**
 * 64.最小路径和
 *
 * 描述：给定一个长宽n*m长方形网格，每个单元格都对应一个整数
 * 起点左上角，终点右下角，从起点走到终点的路径中哪条路径累加和最小
 * 并返回最小和路径值，限制仅能向下走或向右走
 *
 * 示例：
 * 输入：grid = [[1,3,1], [1,5,1], [4,2,1]]
 * 输出：7
 * 最小路径和为 1-3-1-1-1 累加和为 7
 *
 * 示例：
 * 输入：grid = [[1,2,3], [4,5,6]]
 * 输出：12
 * 最小路径和为 1-2-3-6 累加和为 12
 */

/**
 * 动态规划
 *
 * dp[i][j] 表示从左上角走到第(i,j)单元格时，路径数值累加和最小
 * dp[i][j] = Math.min(grid[i-1][j], grid[i][j-1])
 *
 * 解题思路，
 * 1. 边界条件，dp[0][0] = grid[0][0]
 * 2. 第一行，只能往右走到达，所以 i>0 && j=0 时，dp[i][0] = dp[i-1][0] + grid[i][0]
 * 3. 第一列，只能往下走到达，所以 i=0 && j>0 时，dp[0][j] = dp[0][j-1] + grid[0][j]
 * 4. 非第一行第一列的网格单元，既可以往右走又可以往下走，
 * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
 * 最后返回 dp[m-1][n-1]
 *
 * 累加过程是从左上角起点开始，先把第一行边向右移边累加，
 * 再第一列边向下移边累加，再开始一行一行累加，根据上面和左边的最小值累加的
 * 最后走到 [m-1][n-1] 位置时，直接返回当前值就是最小路径和了，
 * 因为每走一步都已经计算好了当前[i][j]位置的最小路径和
 *
 * grid = [[1,2,3],[4,5,6]]
 * 最终计算得到的 dp = [[1,3,6],[5,8,12]]
 */
const minPathSum = function (grid) {
  let m = grid.length;
  let n = grid[0].length;

  const dp = new Array(m).fill(0).map(() => {
    return new Array(n).fill(0);
  });

  dp[0][0] = grid[0][0];

  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[m - 1][n - 1];
};
