/**
 * 338.二进制计数
 *
 * 描述：给定一个整数 n，计算n转换成二进制后，1 的个数
 * 并返回从 0～n 每个元素对应的 1 的个数所构成的长度为 n+1 的数组
 *
 * 示例：
 * 输入：n = 2
 * 输出：[0,1,1]
 * 0 - 0 - 0
 * 1 - 1 - 1
 * 2 - 10 - 1
 *
 * 输入：n = 5
 * 输出；[0,1,1,2,1,2]
 * 0 - 0 - 0
 * 1 - 1 - 1
 * 2 - 10 - 1
 * 3 - 11 - 2
 * 4 - 100 - 1
 * 5 - 101 - 2
 */

/**
 * 动态规划
 *
 * 确定 dp[i] 表示在第 i 个元素整数对应的二进制中 1 的个数
 * 找规律看二进制 1 的个数，0 特殊就是 0
 * 奇数i，肯定比前一个数i-1 多一个1
 * dp[i] = dp[i - 1] + 1
 * 偶数i，就相当于是 i/2 右移的一位，1的数量是一样的
 * dp[i] = dp[i >> 1] 等价于
 * dp[i] = dp[i / 2]
 */
const countBits = function (n) {
  let dp = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    if (i % 2 === 1) {
      dp[i] = dp[i - 1] + 1;
    } else {
      dp[i] = dp[i >> 1];
    }
  }
  return dp;
};

/**
 * dp[i] = dp[i >> 1] + (i & 1)
 * 除以2，加上余数有多少个 1，奇偶都包括了
 */
const countBitsBetter = function (n) {
  const dp = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    dp[i] = dp[i >> 1] + (i & 1);
  }
  return dp;
};
